
//
// This file has been generated by the Cornerstone file generator.
//
// PLEASE, DO NOT EDIT IT MANUALLY
//

#include "MOXClient.h"
#include "search/Search.h"
#include "RpcClientWorker.h"
#include "WorkerUtils.h"
#include "GrpcIncludesBegin.h"
#include <grpc/support/log.h>
#include <grpc++/channel.h>
#include "ChannelProvider.h"
#include "Wrappers/search.pb.hpp"
#include "Wrappers/search.grpc.pb.hpp"
#include "GrpcIncludesEnd.h"
#include "search/SearchCasts.h"
class MOXCLIENT_API GreeterServiceRpcClientWorker : public TStubbedRpcWorker<GreeterService::Stub>
{

public:
    // Conduits and GRPC stub
    TConduit<TRequestWithContext<FSearch_SearchRequest>, TResponseWithStatus<FSearch_SearchResponse>>* SearchConduit;



    // Methods
    TResponseWithStatus<FSearch_SearchResponse> Search(const FSearch_SearchRequest& Request, const FGrpcClientContext& Context)
    {
        return AsyncRequest<FSearch_SearchRequest, SearchRequest, FSearch_SearchResponse, SearchResponse>(Request, Context, &decltype(Stub)::element_type::AsyncSearch);
    }

    bool HierarchicalInit() override
    {
        // No need to call Super::HierarchicalInit(), it isn't required by design
        std::shared_ptr<grpc::Channel> Channel = channel::CreateChannel(this);
        if (!Channel.get())
            return false;

        Stub = GreeterService::NewStub(Channel);

        SearchConduit->AcquireResponsesProducer();

        return true;
    }

    void HierarchicalUpdate() override
    {
        // No need to call Super::HierarchicalUpdate(), it isn't required by design
        if (!SearchConduit->IsEmpty())
        {
            TRequestWithContext<FSearch_SearchRequest> WrappedRequest;
            SearchConduit->Dequeue(WrappedRequest);

            const TResponseWithStatus<FSearch_SearchResponse>& WrappedResponse =
                Search(WrappedRequest.Request, WrappedRequest.Context);
            SearchConduit->Enqueue(WrappedResponse);
        }
    }
};


void UGreeterServiceRpcClient::HierarchicalInit()
{
    // No need to call Super::HierarchicalInit(), it isn't required by design
    GreeterServiceRpcClientWorker* const Worker = new GreeterServiceRpcClientWorker();

    Worker->SearchConduit = &SearchConduit;
    SearchConduit.AcquireRequestsProducer();

    InnerWorker = TUniquePtr<RpcClientWorker>(Worker);
}

void UGreeterServiceRpcClient::HierarchicalUpdate()
{
    // No need to call Super::HierarchicalUpdate(), it isn't required by design
    if (!SearchConduit.IsEmpty())
    {
        TResponseWithStatus<FSearch_SearchResponse> ResponseWithStatus;
        while (SearchConduit.Dequeue(ResponseWithStatus))
            EventSearch.Broadcast(
                this,
                ResponseWithStatus.Response,
                ResponseWithStatus.Status
            );
    }
}

bool UGreeterServiceRpcClient::Search(FSearch_SearchRequest Request, const FGrpcClientContext& Context)
{
    if (!CanSendRequests())
        return false;

    SearchConduit.Enqueue(TRequestWithContext$New(Request, Context));
    return true;
}


